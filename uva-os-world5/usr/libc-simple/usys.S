# part of xv6 userspace lib, minimalist, no dep on libc

# generated by usys.py 
#  ./usys.py  > user_sys.S       then manual edit by FL

# .section ".text.user" 
#include "../../kernel/syscall.h" 

.globl fork
    fork:
    mov x8, #SYS_fork
    svc #0
    ret          
          

.globl exit
    exit:
    mov x8, #SYS_exit
    svc #0
    ret          
          

.globl wait
    wait:
    mov x8, #SYS_wait
    svc #0
    ret          
          

.globl pipe
    pipe:
    mov x8, #SYS_pipe
    svc #0
    ret          
          

.globl read
    read:
    mov x8, #SYS_read
    svc #0
    ret          
          

.globl write
    write:
    mov x8, #SYS_write
    svc #0
    ret          
          

.globl close
    close:
    mov x8, #SYS_close
    svc #0
    ret          
          

.globl kill
    kill:
    mov x8, #SYS_kill
    svc #0
    ret          
          

.globl exec
    exec:
    mov x8, #SYS_exec
    svc #0
    ret          
          

.globl open
    open:
    mov x8, #SYS_open
    svc #0
    ret          
          
.globl mknod
    mknod:
    mov x8, #SYS_mknod
    svc #0
    ret          
          

.globl unlink
    unlink:
    mov x8, #SYS_unlink
    svc #0
    ret          
          

.globl fstat
    fstat:
    mov x8, #SYS_fstat
    svc #0
    ret          
          

.globl link
    link:
    mov x8, #SYS_link
    svc #0
    ret          
          

.globl mkdir
    mkdir:
    mov x8, #SYS_mkdir
    svc #0
    ret          
          

.globl chdir
    chdir:
    mov x8, #SYS_chdir
    svc #0
    ret          
          

.globl dup
    dup:
    mov x8, #SYS_dup
    svc #0
    ret          
          

.globl getpid
    getpid:
    mov x8, #SYS_getpid
    svc #0
    ret          
          

.globl sbrk
    sbrk:
    mov x8, #SYS_sbrk
    svc #0
    ret          
          

.globl sleep
    sleep:
    mov x8, #SYS_sleep
    svc #0
    ret          
          

.globl uptime
    uptime:
    mov x8, #SYS_uptime
    svc #0
    ret          
          
.globl lseek
    lseek:
    mov x8, #SYS_lseek
    svc #0
    ret

//quest: music player
.globl clone
// cf musl clone.s
// clone(func, stack, flags, arg, ptid, tls, ctid)
//         x0,   x1,    w2,    x3,  x4,   x5,  x6

// syscall(SYS_clone, flags, stack, ptid, tls, ctid)
//         x8,        x0,    x1,    x2,   x3,  x4
.type clone, %function
clone:
    // align stack; save "func", "arg" on the stack. 
    // this is b/c the code below dos not pass "func" "arg" to the clone() syscall; 
    // in fact, these are irrelevant to the kernel. they only matter to the 
    // the child thread, which will load them after the clone() syscall returns
    and x1,x1,#-16
    stp x0,x3,[x1,#-16]!

    // syscall
    uxtw x0,w2
    mov x2,x4
    mov x3,x5
    mov x4,x6
    mov x8,#SYS_clone
    svc #0

    cbz x0,1f
    // PARENT - done
    ret
    // CHILD 
    // it must jump to its own entry (unlike fork()), b/c it has a 
    // fresh stack which is empty; it cannot "ret" here --> will crash 
    // below: load the "func", "arg" from the stack, and jump to "func"
1: ldp x1,x0,[sp],#16 /* STUDENT_TODO: replace this */
    blr x1
    mov x8,#SYS_exit
    svc #0

// semaphores 
.globl semcreate
    semcreate:
    mov x8, #SYS_semcreate
    svc #0
    ret

.globl semfree
    semfree:
    mov x8, #SYS_semfree
    svc #0
    ret

.globl semp
    semp:
    mov x8, #SYS_semp
    svc #0
    ret

.globl semv
    semv:
    mov x8, #SYS_semv
    svc #0
    ret